<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Tory's Server</title>
		<style>
			@import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

			:root {
				--bg-color: #fdfbf7; /* Soft Warm White */
				--text-main: #2d3436;
				--text-sub: #636e72;
				--glass-card-bg: rgba(255, 255, 255, 0.65);
				--glass-border: rgba(255, 255, 255, 0.8);
			}

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family:
					'Pretendard',
					-apple-system,
					BlinkMacSystemFont,
					system-ui,
					Roboto,
					sans-serif;
				background-color: var(--bg-color);
				color: var(--text-main);
				height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				overflow: hidden;
				position: relative;
			}

			/* Canvas for Floating 3D Glass Cubes */
			#bgCanvas {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				z-index: 0;
				/* Sharp rendering enabled (Blur removed) */
			}

			.container {
				position: relative;
				z-index: 10;
				background: var(--glass-card-bg);
				backdrop-filter: blur(40px) saturate(180%);
				-webkit-backdrop-filter: blur(40px) saturate(180%);
				padding: 4.5rem 4rem;
				border-radius: 48px;
				border: 2px solid #ffffff;
				text-align: center;
				max-width: 680px;
				width: 90%;
				box-shadow:
					0 20px 40px rgba(0, 0, 0, 0.05),
					0 0 0 1px rgba(255, 255, 255, 0.5) inset;
				transition:
					transform 0.3s ease,
					box-shadow 0.3s ease;
			}

			.container:hover {
				transform: translateY(-5px);
				box-shadow:
					0 30px 60px rgba(0, 0, 0, 0.08),
					0 0 0 1px rgba(255, 255, 255, 0.6) inset;
			}

			/* Status Badge */
			.badge {
				display: inline-flex;
				align-items: center;
				gap: 8px;
				padding: 10px 24px;
				background: #ffffff;
				border-radius: 100px;
				font-size: 0.9rem;
				font-weight: 700;
				color: #2d3436;
				margin-bottom: 2rem;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
				border: 1px solid rgba(0, 0, 0, 0.05);
			}

			.badge-dot {
				width: 10px;
				height: 10px;
				background-color: #00cec9; /* Vibrant Teal */
				border-radius: 50%;
				box-shadow: 0 0 0 3px rgba(0, 206, 201, 0.2);
				animation: pulse 2s infinite;
			}

			h1 {
				font-size: 4.5rem;
				font-weight: 900;
				margin-bottom: 1rem;
				letter-spacing: -0.04em;
				/* Multi-color gradient text */
				background: linear-gradient(135deg, #6c5ce7 0%, #fd79a8 100%);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
			}

			p {
				font-size: 1.35rem;
				line-height: 1.6;
				color: var(--text-sub);
				margin-bottom: 3rem;
				font-weight: 500;
			}

			footer {
				font-size: 0.9rem;
				color: #b2bec3;
				font-weight: 600;
			}

			@keyframes pulse {
				0% {
					transform: scale(0.95);
					box-shadow: 0 0 0 0 rgba(0, 206, 201, 0.4);
				}
				70% {
					transform: scale(1);
					box-shadow: 0 0 0 8px rgba(0, 206, 201, 0);
				}
				100% {
					transform: scale(0.95);
					box-shadow: 0 0 0 0 rgba(0, 206, 201, 0);
				}
			}

			@media (max-width: 768px) {
				h1 {
					font-size: 3rem;
				}
				.container {
					padding: 3rem 2rem;
				}
			}
		</style>
	</head>
	<body>
		<canvas id="bgCanvas"></canvas>

		<div class="container">
			<h1>Tory's Server</h1>
			<p>Welcome to Tory Space!</p>
			<footer>&copy; 2025 Tory's Server. All Rights Reserved.</footer>
		</div>

		<script>
			/**
			 * 3D Rainbow Glass Cubes Animation (High-Res & Vivid)
			 * Sharp edges, summer sunlight reflections, rounded seamless form.
			 */
			const canvas = document.getElementById('bgCanvas');
			const ctx = canvas.getContext('2d');

			let width, height;
			let cubes = [];
			let tick = 0;

			function resize() {
				// Force High Resolution (Retina/HiDPI)
				// Use at least 2.0 for sharp rendering
				const dpr = Math.max(window.devicePixelRatio || 1, 2);

				width = window.innerWidth;
				height = window.innerHeight;

				// Set actual bitmap size to hi-dpi
				canvas.width = width * dpr;
				canvas.height = height * dpr;

				// Scale context to match
				ctx.scale(dpr, dpr);

				// Reset cubes on resize
				initCubes();
			}
			window.addEventListener('resize', resize);

			const mouse = { x: undefined, y: undefined };
			window.addEventListener('mousemove', (e) => {
				mouse.x = e.x;
				mouse.y = e.y;
			});
			window.addEventListener('mouseleave', () => {
				mouse.x = undefined;
				mouse.y = undefined;
			});

			const POINT3D = function (x, y, z) {
				this.x = x;
				this.y = y;
				this.z = z;
			};

			class RainbowCube3D {
				constructor() {
					this.init();

					this.vertices = [
						new POINT3D(-1, -1, -1),
						new POINT3D(1, -1, -1),
						new POINT3D(1, 1, -1),
						new POINT3D(-1, 1, -1),
						new POINT3D(-1, -1, 1),
						new POINT3D(1, -1, 1),
						new POINT3D(1, 1, 1),
						new POINT3D(-1, 1, 1)
					];

					this.faces = [
						[0, 1, 2, 3],
						[1, 5, 6, 2],
						[5, 4, 7, 6],
						[4, 0, 3, 7],
						[3, 2, 6, 7],
						[4, 5, 1, 0]
					];
				}

				init() {
					this.size = Math.random() * 50 + 30;
					this.x = Math.random() * width;
					this.y = Math.random() * height;
					this.z = Math.random() * 0.5 + 0.5;

					this.vx = (Math.random() - 0.5) * 0.5;
					this.vy = (Math.random() - 0.5) * 0.5;

					this.rx = Math.random() * Math.PI * 2;
					this.ry = Math.random() * Math.PI * 2;

					this.vrx = (Math.random() - 0.5) * 0.015;
					this.vry = (Math.random() - 0.5) * 0.015;

					this.hueOffset = Math.random() * 360;
				}

				project(x, y, z) {
					return {
						x: this.x + x * this.size,
						y: this.y + y * this.size
					};
				}

				rotate(p, rx, ry) {
					let x1 = p.x * Math.cos(ry) - p.z * Math.sin(ry);
					let z1 = p.x * Math.sin(ry) + p.z * Math.cos(ry);
					let y1 = p.y * Math.cos(rx) - z1 * Math.sin(rx);
					let z2 = p.y * Math.sin(rx) + z1 * Math.cos(rx);
					return new POINT3D(x1, y1, z2);
				}

				update() {
					this.x += this.vx * this.z;
					this.y += this.vy * this.z;
					this.rx += this.vrx;
					this.ry += this.vry;

					if (mouse.x !== undefined) {
						const dx = this.x - mouse.x;
						const dy = this.y - mouse.y;
						const dist = Math.sqrt(dx * dx + dy * dy);
						const radius = 300;

						if (dist < radius) {
							const force = (radius - dist) / radius;
							this.x += (dx / dist) * force * 2;
							this.y += (dy / dist) * force * 2;
							this.rx += this.vrx * 2;
							this.ry += this.vry * 2;
						}
					}

					const margin = 150;
					if (this.x < -margin) this.x = width + margin;
					if (this.x > width + margin) this.x = -margin;
					if (this.y < -margin) this.y = height + margin;
					if (this.y > height + margin) this.y = -margin;
				}

				draw(ctx) {
					// 1. 3D Transformation
					let transformedVertices = this.vertices.map((v) => {
						let x1 = v.x * Math.cos(this.ry) - v.z * Math.sin(this.ry);
						let z1 = v.x * Math.sin(this.ry) + v.z * Math.cos(this.ry);
						let y1 = v.y * Math.cos(this.rx) - z1 * Math.sin(this.rx);
						let z2 = v.y * Math.sin(this.rx) + z1 * Math.cos(this.rx);
						return { x: x1, y: y1, z: z2 };
					});

					let projectedPoints = transformedVertices.map((v) => this.project(v.x, v.y, v.z));

					// 2. Lighting
					const lightDir = { x: 0.5, y: -0.8, z: -1 };
					const len = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);
					lightDir.x /= len;
					lightDir.y /= len;
					lightDir.z /= len;

					ctx.lineJoin = 'round';
					ctx.lineCap = 'round';

					this.faces.forEach((face) => {
						// 3. Normal
						const v0 = transformedVertices[face[0]];
						const v1 = transformedVertices[face[1]];
						const v2 = transformedVertices[face[2]];

						const A = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };
						const B = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };

						const nx = A.y * B.z - A.z * B.y;
						const ny = A.z * B.x - A.x * B.z;
						const nz = A.x * B.y - A.y * B.x;

						const nLen = Math.sqrt(nx * nx + ny * ny + nz * nz);
						const normal = { x: nx / nLen, y: ny / nLen, z: nz / nLen };

						// 4. Intensity
						let intensity = normal.x * lightDir.x + normal.y * lightDir.y + normal.z * lightDir.z;
						let brightness = Math.max(0.2, intensity);

						// 5. Vivid Sunlit Glass Color
						const alpha = 0.6 + brightness * 0.3; // 0.6 ~ 0.9
						const lightness = 75 + brightness * 15; // 75% ~ 90%

						const p = face.map((idx) => projectedPoints[idx]);

						// Seamless Gradient: The key is using the SAME gradient for stroke and fill
						const grad = ctx.createLinearGradient(p[0].x, p[0].y, p[2].x, p[2].y);
						grad.addColorStop(0.0, `hsla(340, 100%, ${lightness}%, ${alpha})`); // Vivid Pink
						grad.addColorStop(0.3, `hsla(40,  100%, ${lightness}%, ${alpha})`); // Vivid Yellow
						grad.addColorStop(0.6, `hsla(200, 100%, ${lightness}%, ${alpha})`); // Vivid Blue
						grad.addColorStop(1.0, `hsla(260, 100%, ${lightness}%, ${alpha})`); // Vivid Purple

						ctx.beginPath();
						ctx.moveTo(p[0].x, p[0].y);
						ctx.lineTo(p[1].x, p[1].y);
						ctx.lineTo(p[2].x, p[2].y);
						ctx.lineTo(p[3].x, p[3].y);
						ctx.closePath();

						// Apply SAME gradient to both fill and stroke for seamless look
						ctx.fillStyle = grad;
						ctx.strokeStyle = grad;
						ctx.lineWidth = 32; // Large width for rounded corners

						ctx.stroke();
						ctx.fill();

						// Sharp Specular Highlight (Ray Tracing Effect)
						if (intensity > 0.5) {
							const glossOpacity = (intensity - 0.5) * 0.9;
							const glossGrad = ctx.createLinearGradient(p[0].x, p[0].y, p[2].x, p[2].y);
							glossGrad.addColorStop(0, `rgba(255, 255, 255, ${glossOpacity})`);
							glossGrad.addColorStop(0.6, `rgba(255, 255, 255, 0)`);

							ctx.fillStyle = glossGrad;
							ctx.fill();
						}
					});
				}
			}

			function initCubes() {
				cubes = [];
				const numCubes = Math.floor((width * height) / 100000);
				for (let i = 0; i < numCubes; i++) {
					cubes.push(new RainbowCube3D());
				}
			}

			function animate() {
				ctx.clearRect(0, 0, width, height);
				tick++;

				for (let i = 0; i < cubes.length; i++) {
					cubes[i].update();
					cubes[i].draw(ctx);
				}

				requestAnimationFrame(animate);
			}

			resize();
			animate();
		</script>
	</body>
</html>
